pragma solidity 0.6.6;

import "./BondExchange.sol";

abstract contract BondVsBondExchange is BondExchange {
    /**
     * @dev the sum of decimalsOfBond and decimalsOfOraclePrice of the bondMaker.
     * This value is constant by the restriction of `_assertBondMakerDecimals`.
     */
    uint8 internal constant DECIMALS_OF_BOND_VALUE = DECIMALS_OF_BOND +
        DECIMALS_OF_ORACLE_PRICE;

    struct VsBondPool {
        address seller;
        BondMakerInterface bondMakerForUser;
        VolatilityOracleInterface volatilityOracle;
        BondPricerInterface bondPricerForUser;
        BondPricerInterface bondPricer;
        int16 feeBaseE4;
    }
    mapping(bytes32 => VsBondPool) internal _vsBondPool;

    event LogCreateBondToBondPool(
        bytes32 indexed poolID,
        address indexed seller,
        address indexed bondMakerForUser
    );

    event LogUpdateVsBondPool(
        bytes32 indexed poolID,
        address bondPricerForUser,
        address bondPricer,
        int16 feeBase // decimal: 4
    );

    event LogDeleteVsBondPool(bytes32 indexed poolID);

    event LogExchangeBondToBond(
        address indexed buyer,
        bytes32 indexed bondID,
        bytes32 indexed poolID,
        uint256 bondAmount, // decimal: 8
        uint256 swapPairAmount, // USD, decimal: 8
        uint256 volume // USD, decimal: 8
    );

    /**
     * @dev Reverts when the pool ID does not exist.
     */
    modifier isExsistentVsBondPool(bytes32 poolID) {
        require(
            _vsBondPool[poolID].seller != address(0),
            "the exchange pair does not exist"
        );
        _;
    }

    /**
     * @notice Exchange the seller's bond to buyer's multiple bonds.
     * @dev Ensure the seller has approved sufficient bonds and
     * Approve bonds to pay before executing this function.
     * @param bondID is the target bond ID.
     * @param poolID is the target pool ID.
     * @param amountInDollarsE8 is the exchange pair token amount to pay. (decimals: 8)
     * @param expectedAmount is the bond amount to receive. (decimals: 8)
     * @param range (decimal: 3)
     */
    function exchangeBondToBond(
        bytes32 bondID,
        bytes32 poolID,
        bytes32[] calldata bondIDs,
        uint256 amountInDollarsE8,
        uint256 expectedAmount,
        uint256 range
    ) external returns (uint256 bondAmount) {
        uint256 amountInDollars = _applyDecimalGap(
            amountInDollarsE8,
            8,
            DECIMALS_OF_BOND_VALUE
        );
        bondAmount = _exchangeBondToBond(
            msg.sender,
            bondID,
            poolID,
            bondIDs,
            amountInDollars
        );
        _assertExpectedPriceRange(bondAmount, expectedAmount, range);
    }

    /**
     * @notice Returns the exchange rate including spread.
     */
    function calcRateBondToUsd(bytes32 bondID, bytes32 poolID)
        external
        returns (uint256 rateE8)
    {
        (rateE8, , , ) = _calcRateBondToUsd(bondID, poolID);
    }

    /**
     * @notice Returns pool ID generated by the immutable pool settings.
     */
    function generateVsBondPoolID(address seller, address bondMakerForUser)
        external
        view
        returns (bytes32 poolID)
    {
        return _generateVsBondPoolID(seller, bondMakerForUser);
    }

    /**
     * @notice Register a new vsBondPool.
     */
    function createVsBondPool(
        BondMakerInterface bondMakerForUserAddress,
        VolatilityOracleInterface volatilityOracleAddress,
        BondPricerInterface bondPricerForUserAddress,
        BondPricerInterface bondPricerAddress,
        int16 feeBaseE4
    ) external returns (bytes32 poolID) {
        return
            _createVsBondPool(
                msg.sender,
                bondMakerForUserAddress,
                volatilityOracleAddress,
                bondPricerForUserAddress,
                bondPricerAddress,
                feeBaseE4
            );
    }

    /**
     * @notice Update the mutable pool settings.
     */
    function updateVsBondPool(
        bytes32 poolID,
        VolatilityOracleInterface volatilityOracleAddress,
        BondPricerInterface bondPricerForUserAddress,
        BondPricerInterface bondPricerAddress,
        int16 feeBaseE4
    ) external {
        require(
            _vsBondPool[poolID].seller == msg.sender,
            "not the owner of the pool ID"
        );

        _updateVsBondPool(
            poolID,
            volatilityOracleAddress,
            bondPricerForUserAddress,
            bondPricerAddress,
            feeBaseE4
        );
    }

    /**
     * @notice Delete the pool settings.
     */
    function deleteVsBondPool(bytes32 poolID) external {
        require(
            _vsBondPool[poolID].seller == msg.sender,
            "not the owner of the pool ID"
        );

        _deleteVsBondPool(poolID);
    }

    /**
     * @notice Returns the pool settings.
     */
    function getVsBondPool(bytes32 poolID)
        external
        view
        returns (
            address seller,
            BondMakerInterface bondMakerForUserAddress,
            VolatilityOracleInterface volatilityOracle,
            BondPricerInterface bondPricerForUserAddress,
            BondPricerInterface bondPricerAddress,
            int16 feeBaseE4,
            bool isBondSale
        )
    {
        return _getVsBondPool(poolID);
    }

    /**
     * @notice Returns the total approved bond amount in U.S. dollars.
     * Unnecessary bond must not be included in bondIDs.
     */
    function totalBondAllowance(
        bytes32 poolID,
        bytes32[] calldata bondIDs,
        uint256 maturityBorder,
        address owner
    ) external returns (uint256 allowanceInDollarsE8) {
        (
            ,
            BondMakerInterface bondMakerForUser,
            VolatilityOracleInterface volatilityOracle,
            BondPricerInterface bondPricerForUser,
            ,
            ,

        ) = _getVsBondPool(poolID);
        uint256 allowanceInDollars = _totalBondAllowance(
            bondMakerForUser,
            volatilityOracle,
            bondPricerForUser,
            bondIDs,
            maturityBorder,
            owner
        );
        allowanceInDollarsE8 = _applyDecimalGap(
            allowanceInDollars,
            DECIMALS_OF_BOND_VALUE,
            8
        );
    }

    /**
     * @dev Exchange the seller's bond to buyer's multiple bonds.
     * Ensure the seller has approved sufficient bonds and
     * buyer approve bonds to pay before executing this function.
     * @param buyer is the buyer address.
     * @param bondID is the target bond ID.
     * @param poolID is the target pool ID.
     * @param amountInDollars is the exchange pair token amount to pay. (decimals: 16)
     * @return bondAmount is the received bond amount.
     */
    function _exchangeBondToBond(
        address buyer,
        bytes32 bondID,
        bytes32 poolID,
        bytes32[] memory bondIDs,
        uint256 amountInDollars
    ) internal returns (uint256 bondAmount) {
        require(bondIDs.length != 0, "must input bonds for payment");

        BondMakerInterface bondMakerForUser;
        {
            bool isBondSale;
            (, bondMakerForUser, , , , , isBondSale) = _getVsBondPool(poolID);
            require(isBondSale, "This pool is for buying bond");
        }

        (ERC20 bondToken, uint256 maturity, , ) = _getBond(
            _bondMakerContract,
            bondID
        );
        require(address(bondToken) != address(0), "the bond is not registered");

        {
            (uint256 rateE8, , , ) = _calcRateBondToUsd(bondID, poolID);
            require(
                rateE8 > MIN_EXCHANGE_RATE_E8,
                "exchange rate is too small"
            );
            require(
                rateE8 < MAX_EXCHANGE_RATE_E8,
                "exchange rate is too large"
            );
            bondAmount =
                _applyDecimalGap(
                    amountInDollars,
                    DECIMALS_OF_BOND_VALUE,
                    bondToken.decimals() + 8
                ) /
                rateE8;
            require(bondAmount != 0, "must transfer non-zero bond amount");
        }

        {
            (
                address seller,
                ,
                VolatilityOracleInterface volatilityOracle,
                BondPricerInterface bondPricerForUser,
                ,
                ,

            ) = _getVsBondPool(poolID);
            require(
                bondToken.transferFrom(seller, buyer, bondAmount),
                "fail to transfer bonds"
            );

            address buyerTmp = buyer; // avoid `stack too deep` error
            uint256 amountInDollarsTmp = amountInDollars; // avoid `stack too deep` error
            require(
                _batchTransferBondFrom(
                    bondMakerForUser,
                    volatilityOracle,
                    bondPricerForUser,
                    bondIDs,
                    maturity,
                    buyerTmp,
                    seller,
                    amountInDollarsTmp
                ),
                "fail to transfer ERC20 token"
            );
        }

        uint256 volumeE8 = _applyDecimalGap(
            amountInDollars,
            DECIMALS_OF_BOND_VALUE,
            8
        );
        emit LogExchangeBondToBond(
            buyer,
            bondID,
            poolID,
            bondAmount,
            amountInDollars,
            volumeE8
        );
    }

    function _calcRateBondToUsd(bytes32 bondID, bytes32 poolID)
        internal
        returns (
            uint256 rateE8,
            uint256 bondPriceE8,
            uint256 swapPairPriceE8,
            int256 spreadE8
        )
    {
        (
            ,
            ,
            ,
            ,
            BondPricerInterface bondPricer,
            int16 feeBaseE4,

        ) = _getVsBondPool(poolID);
        (bondPriceE8, spreadE8) = _calcBondPriceAndSpread(
            bondPricer,
            bondID,
            feeBaseE4
        );
        bondPriceE8 = _calcUsdPrice(bondPriceE8);
        swapPairPriceE8 = 10**8;
        rateE8 = bondPriceE8.mul(uint256(10**8 + spreadE8)) / 10**8;
    }

    function _generateVsBondPoolID(address seller, address bondMakerForUser)
        internal
        view
        returns (bytes32 poolID)
    {
        return
            keccak256(
                abi.encode(
                    "Bond vs SBT exchange",
                    address(this),
                    seller,
                    bondMakerForUser
                )
            );
    }

    function _setVsBondPool(
        bytes32 poolID,
        address seller,
        BondMakerInterface bondMakerForUser,
        VolatilityOracleInterface volatilityOracle,
        BondPricerInterface bondPricerForUser,
        BondPricerInterface bondPricer,
        int16 feeBaseE4
    ) internal {
        require(seller != address(0), "the pool ID already exists");
        require(
            address(bondMakerForUser) != address(0),
            "bondMakerForUser should be non-zero address"
        );
        require(
            address(bondPricerForUser) != address(0),
            "bondPricerForUser should be non-zero address"
        );
        require(
            address(bondPricer) != address(0),
            "bondPricer should be non-zero address"
        );
        _assertBondMakerDecimals(bondMakerForUser);
        _vsBondPool[poolID] = VsBondPool({
            seller: seller,
            bondMakerForUser: bondMakerForUser,
            volatilityOracle: volatilityOracle,
            bondPricerForUser: bondPricerForUser,
            bondPricer: bondPricer,
            feeBaseE4: feeBaseE4
        });
    }

    function _createVsBondPool(
        address seller,
        BondMakerInterface bondMakerForUser,
        VolatilityOracleInterface volatilityOracle,
        BondPricerInterface bondPricerForUser,
        BondPricerInterface bondPricer,
        int16 feeBaseE4
    ) internal returns (bytes32 poolID) {
        poolID = _generateVsBondPoolID(seller, address(bondMakerForUser));
        require(
            _vsBondPool[poolID].seller == address(0),
            "the pool ID already exists"
        );

        _assertBondMakerDecimals(bondMakerForUser);
        _setVsBondPool(
            poolID,
            seller,
            bondMakerForUser,
            volatilityOracle,
            bondPricerForUser,
            bondPricer,
            feeBaseE4
        );

        emit LogCreateBondToBondPool(poolID, seller, address(bondMakerForUser));
        emit LogUpdateVsBondPool(
            poolID,
            address(bondPricerForUser),
            address(bondPricer),
            feeBaseE4
        );
    }

    function _updateVsBondPool(
        bytes32 poolID,
        VolatilityOracleInterface volatilityOracle,
        BondPricerInterface bondPricerForUser,
        BondPricerInterface bondPricer,
        int16 feeBaseE4
    ) internal isExsistentVsBondPool(poolID) {
        (
            address seller,
            BondMakerInterface bondMakerForUser,
            ,
            ,
            ,
            ,

        ) = _getVsBondPool(poolID);
        _setVsBondPool(
            poolID,
            seller,
            bondMakerForUser,
            volatilityOracle,
            bondPricerForUser,
            bondPricer,
            feeBaseE4
        );

        emit LogUpdateVsBondPool(
            poolID,
            address(bondPricerForUser),
            address(bondPricer),
            feeBaseE4
        );
    }

    function _deleteVsBondPool(bytes32 poolID)
        internal
        isExsistentVsBondPool(poolID)
    {
        delete _vsBondPool[poolID];

        emit LogDeleteVsBondPool(poolID);
    }

    function _getVsBondPool(bytes32 poolID)
        internal
        view
        isExsistentVsBondPool(poolID)
        returns (
            address seller,
            BondMakerInterface bondMakerForUser,
            VolatilityOracleInterface volatilityOracle,
            BondPricerInterface bondPricerForUser,
            BondPricerInterface bondPricer,
            int16 feeBaseE4,
            bool isBondSale
        )
    {
        VsBondPool memory exchangePair = _vsBondPool[poolID];
        seller = exchangePair.seller;
        bondMakerForUser = exchangePair.bondMakerForUser;
        volatilityOracle = exchangePair.volatilityOracle;
        bondPricerForUser = exchangePair.bondPricerForUser;
        bondPricer = exchangePair.bondPricer;
        feeBaseE4 = exchangePair.feeBaseE4;
        isBondSale = true;
    }

    /**
     * @dev Transfer multiple bonds in one method.
     * Unnecessary bonds can be included in bondIDs.
     */
    function _batchTransferBondFrom(
        BondMakerInterface bondMaker,
        VolatilityOracleInterface volatilityOracle,
        BondPricerInterface bondPricer,
        bytes32[] memory bondIDs,
        uint256 maturityBorder,
        address sender,
        address recipient,
        uint256 amountInDollars
    ) internal returns (bool ok) {
        uint256 oraclePriceE8 = _getLatestPrice(bondMaker.oracleAddress());

        uint256 rest = amountInDollars; // mutable
        for (uint256 i = 0; i < bondIDs.length; i++) {
            ERC20 bond;
            uint256 oracleVolE8;
            {
                uint256 maturity;
                (bond, maturity, , ) = _getBond(bondMaker, bondIDs[i]);
                if (maturity > maturityBorder) continue; // skip transaction
                uint256 untilMaturity = maturity.sub(
                    _getBlockTimestampSec(),
                    "the bond should not have expired"
                );
                oracleVolE8 = _getVolatility(
                    volatilityOracle,
                    untilMaturity.toUint64()
                );
            }

            uint256 allowance = bond.allowance(sender, address(this));
            if (allowance == 0) continue; // skip transaction

            BondMakerInterface bondMakerTmp = bondMaker; // avoid `stack too deep` error
            BondPricerInterface bondPricerTmp = bondPricer; // avoid `stack too deep` error
            bytes32 bondIDTmp = bondIDs[i]; // avoid `stack too deep` error
            uint256 bondPrice = _calcBondPrice(
                bondMakerTmp,
                bondPricerTmp,
                bondIDTmp,
                oraclePriceE8,
                oracleVolE8
            );
            if (bondPrice == 0) continue; // skip transaction

            if (rest <= allowance.mul(bondPrice)) {
                // assert(ceil(rest / bondPrice) <= allowance);
                return
                    bond.transferFrom(
                        sender,
                        recipient,
                        rest.divRoundUp(bondPrice)
                    );
            }

            require(
                bond.transferFrom(sender, recipient, allowance),
                "fail to transfer bonds"
            );
            rest -= allowance * bondPrice;
        }

        revert("insufficient bond allowance");
    }

    /**
     * @dev Returns the total approved bond amount in U.S. dollars.
     * Unnecessary bond must not be included in bondIDs.
     */
    function _totalBondAllowance(
        BondMakerInterface bondMaker,
        VolatilityOracleInterface volatilityOracle,
        BondPricerInterface bondPricer,
        bytes32[] memory bondIDs,
        uint256 maturityBorder,
        address sender
    ) internal returns (uint256 allowanceInDollars) {
        uint256 oraclePriceE8 = _getLatestPrice(bondMaker.oracleAddress());

        for (uint256 i = 0; i < bondIDs.length; i++) {
            ERC20 bond;
            uint256 oracleVolE8;
            {
                uint256 maturity;
                (bond, maturity, , ) = _getBond(bondMaker, bondIDs[i]);
                if (maturity > maturityBorder) continue; // skip
                uint256 untilMaturity = maturity.sub(
                    _getBlockTimestampSec(),
                    "the bond should not have expired"
                );
                oracleVolE8 = _getVolatility(
                    volatilityOracle,
                    untilMaturity.toUint64()
                );
            }

            uint256 balance = bond.balanceOf(sender);
            require(balance != 0, "includes no bond balance");

            uint256 allowance = bond.allowance(sender, address(this));
            require(allowance != 0, "includes no approved bond");

            uint256 bondPrice = _calcBondPrice(
                bondMaker,
                bondPricer,
                bondIDs[i],
                oraclePriceE8,
                oracleVolE8
            );
            require(bondPrice != 0, "includes worthless bond");

            allowanceInDollars = allowanceInDollars.add(
                allowance.mul(bondPrice)
            );
        }
    }

    /**
     * @dev Calculate bond price by bond ID.
     */
    function _calcBondPrice(
        BondMakerInterface bondMaker,
        BondPricerInterface bondPricer,
        bytes32 bondID,
        uint256 oraclePriceE8,
        uint256 oracleVolatilityE8
    ) internal view returns (uint256) {
        int256 untilMaturity;
        {
            (, uint256 maturity, , ) = _getBond(bondMaker, bondID);
            untilMaturity = maturity
                .sub(
                _getBlockTimestampSec(),
                "the bond should not have expired"
            )
                .toInt256();
        }

        BondType bondType;
        uint256[] memory points;
        {
            bool isKnownBondType;
            (isKnownBondType, bondType, points) = _bondShapeDetector
                .getBondTypeByID(bondMaker, bondID, BondType.NONE);
            if (!isKnownBondType) {
                revert("unknown bond type");
                // return 0;
            }
        }

        try
            bondPricer.calcPriceAndLeverage(
                bondType,
                points,
                oraclePriceE8.toInt256(),
                oracleVolatilityE8.toInt256(),
                untilMaturity
            )
        returns (uint256 bondPriceE8, uint256) {
            return bondPriceE8;
        } catch {
            return 0;
        }
    }
}
