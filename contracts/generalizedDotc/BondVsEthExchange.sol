pragma solidity 0.6.6;

import "./BondExchange.sol";
import "../util/TransferETH.sol";

abstract contract BondVsEthExchange is BondExchange, TransferETH {
    uint8 internal constant DECIMALS_OF_ETH = 18;

    struct VsEthPool {
        address seller;
        LatestPriceOracleInterface ethOracle;
        BondPricerInterface bondPricer;
        int16 feeBaseE4;
        bool isBondSale;
    }
    mapping(bytes32 => VsEthPool) internal _vsEthPool;

    mapping(address => uint256) internal _depositedEth;

    event LogCreateEthToBondPool(
        bytes32 indexed poolID,
        address indexed seller
    );

    event LogCreateBondToEthPool(
        bytes32 indexed poolID,
        address indexed seller
    );

    event LogUpdateVsEthPool(
        bytes32 indexed poolID,
        address ethOracleAddress,
        address bondPricerAddress,
        int16 feeBase // decimal: 4
    );

    event LogDeleteVsEthPool(bytes32 indexed poolID);

    event LogExchangeEthToBond(
        address indexed buyer,
        bytes32 indexed bondID,
        bytes32 indexed poolID,
        uint256 bondAmount, // decimal: 8
        uint256 swapPairAmount, // decimal: 18
        uint256 volume // USD, decimal: 8
    );

    event LogExchangeBondToEth(
        address indexed buyer,
        bytes32 indexed bondID,
        bytes32 indexed poolID,
        uint256 bondAmount, // decimal: 8
        uint256 swapPairAmount, // decimal: 18
        uint256 volume // USD, decimal: 8
    );

    /**
     * @dev Reverts when the pool ID does not exist.
     */
    modifier isExsistentVsEthPool(bytes32 poolID) {
        require(
            _vsEthPool[poolID].seller != address(0),
            "the exchange pair does not exist"
        );
        _;
    }

    /**
     * @notice Exchange buyer's ETH to the seller's bond.
     * @dev Ensure the seller has approved sufficient bonds and
     * you deposit ETH to pay before executing this function.
     * @param bondID is the target bond ID.
     * @param poolID is the target pool ID.
     * @param ethAmount is the exchange pair token amount to pay.
     * @param expectedAmount is the bond amount to receive.
     * @param range (decimal: 3)
     */
    function exchangeEthToBond(
        bytes32 bondID,
        bytes32 poolID,
        uint256 ethAmount,
        uint256 expectedAmount,
        uint256 range
    ) external returns (uint256 bondAmount) {
        bondAmount = _exchangeEthToBond(msg.sender, bondID, poolID, ethAmount);
        // assert(bondAmount != 0);
        _assertExpectedPriceRange(bondAmount, expectedAmount, range);
    }

    /**
     * @notice Exchange buyer's bond to the seller's ETH.
     * @dev Ensure the seller has deposited sufficient ETH and
     * you approve bonds to pay before executing this function.
     * @param bondID is the target bond ID.
     * @param poolID is the target pool ID.
     * @param bondAmount is the bond amount to pay.
     * @param expectedAmount is the ETH amount to receive.
     * @param range (decimal: 3)
     */
    function exchangeBondToEth(
        bytes32 bondID,
        bytes32 poolID,
        uint256 bondAmount,
        uint256 expectedAmount,
        uint256 range
    ) external returns (uint256 ethAmount) {
        ethAmount = _exchangeBondToEth(msg.sender, bondID, poolID, bondAmount);
        // assert(ethAmount != 0);
        _assertExpectedPriceRange(ethAmount, expectedAmount, range);
    }

    /**
     * @notice Returns the exchange rate including spread.
     */
    function calcRateBondToEth(bytes32 bondID, bytes32 poolID)
        external
        returns (uint256 rateE8)
    {
        (rateE8, , , ) = _calcRateBondToEth(bondID, poolID);
    }

    /**
     * @notice Returns pool ID generated by the immutable pool settings.
     */
    function generateVsEthPoolID(address seller, bool isBondSale)
        external
        view
        returns (bytes32 poolID)
    {
        return _generateVsEthPoolID(seller, isBondSale);
    }

    /**
     * @notice Register a new vsEthPool.
     */
    function createVsEthPool(
        LatestPriceOracleInterface ethOracleAddress,
        BondPricerInterface bondPricerAddress,
        int16 feeBaseE4,
        bool isBondSale
    ) external returns (bytes32 poolID) {
        return
            _createVsEthPool(
                msg.sender,
                ethOracleAddress,
                bondPricerAddress,
                feeBaseE4,
                isBondSale
            );
    }

    /**
     * @notice Update the mutable pool settings.
     */
    function updateVsEthPool(
        bytes32 poolID,
        LatestPriceOracleInterface ethOracleAddress,
        BondPricerInterface bondPricerAddress,
        int16 feeBaseE4
    ) external {
        require(
            _vsEthPool[poolID].seller == msg.sender,
            "not the owner of the pool ID"
        );

        _updateVsEthPool(
            poolID,
            ethOracleAddress,
            bondPricerAddress,
            feeBaseE4
        );
    }

    /**
     * @notice Delete the pool settings.
     */
    function deleteVsEthPool(bytes32 poolID) external {
        require(
            _vsEthPool[poolID].seller == msg.sender,
            "not the owner of the pool ID"
        );

        _deleteVsEthPool(poolID);
    }

    /**
     * @notice Returns the pool settings.
     */
    function getVsEthPool(bytes32 poolID)
        external
        view
        returns (
            address seller,
            LatestPriceOracleInterface ethOracleAddress,
            BondPricerInterface bondPricerAddress,
            int16 feeBaseE4,
            bool isBondSale
        )
    {
        return _getVsEthPool(poolID);
    }

    /**
     * @notice Transfer ETH to this contract and allow this contract to pay ETH when exchanging.
     */
    function depositEth() external payable {
        _addEthAllowance(msg.sender, msg.value);
    }

    /**
     * @notice Withdraw all deposited ETH.
     */
    function withdrawEth() external returns (uint256 amount) {
        amount = _depositedEth[msg.sender];
        _transferEthFrom(msg.sender, msg.sender, amount);
    }

    /**
     * @notice Returns deposited ETH amount.
     */
    function ethAllowance(address owner)
        external
        view
        returns (uint256 amount)
    {
        amount = _depositedEth[owner];
    }

    /**
     * @dev Exchange buyer's ETH to the seller's bond.
     * Ensure the seller has approved sufficient bonds and
     * buyer deposit ETH to pay before executing this function.
     * @param buyer is the buyer address.
     * @param bondID is the target bond ID.
     * @param poolID is the target pool ID.
     * @param swapPairAmount is the exchange pair token amount to pay.
     * @return bondAmount is the received bond amount.
     */
    function _exchangeEthToBond(
        address buyer,
        bytes32 bondID,
        bytes32 poolID,
        uint256 swapPairAmount
    ) internal returns (uint256 bondAmount) {
        (address seller, , , , bool isBondSale) = _getVsEthPool(poolID);
        require(isBondSale, "This pool is for buying bond");

        (ERC20 bondToken, , , ) = _getBond(_bondMakerContract, bondID);
        require(address(bondToken) != address(0), "the bond is not registered");

        uint256 volumeE8;
        {
            (uint256 rateE8, , uint256 swapPairPriceE8, ) = _calcRateBondToEth(
                bondID,
                poolID
            );
            require(
                rateE8 > MIN_EXCHANGE_RATE_E8,
                "exchange rate is too small"
            );
            require(
                rateE8 < MAX_EXCHANGE_RATE_E8,
                "exchange rate is too large"
            );
            bondAmount =
                _applyDecimalGap(
                    swapPairAmount,
                    DECIMALS_OF_ETH,
                    DECIMALS_OF_BOND + 8
                ) /
                rateE8;
            require(bondAmount != 0, "must transfer non-zero bond amount");
            volumeE8 = swapPairPriceE8.mul(swapPairAmount).div(
                10**uint256(DECIMALS_OF_ETH)
            );
        }

        require(
            bondToken.transferFrom(seller, buyer, bondAmount),
            "fail to transfer bonds"
        );
        _transferEthFrom(buyer, seller, swapPairAmount);

        emit LogExchangeEthToBond(
            buyer,
            bondID,
            poolID,
            bondAmount,
            swapPairAmount,
            volumeE8
        );
    }

    /**
     * @dev Exchange buyer's bond to the seller's ETH.
     * Ensure the seller has deposited sufficient ETH and
     * buyer approve bonds to pay before executing this function.
     * @param buyer is the buyer address.
     * @param bondID is the target bond ID.
     * @param poolID is the target pool ID.
     * @param bondAmount is the bond amount to pay.
     * @return swapPairAmount is the received ETH amount.
     */
    function _exchangeBondToEth(
        address buyer,
        bytes32 bondID,
        bytes32 poolID,
        uint256 bondAmount
    ) internal returns (uint256 swapPairAmount) {
        (address seller, , , , bool isBondSale) = _getVsEthPool(poolID);
        require(!isBondSale, "This pool is not for buying bond");

        (ERC20 bondToken, , , ) = _getBond(_bondMakerContract, bondID);
        require(address(bondToken) != address(0), "the bond is not registered");

        uint256 volumeE8;
        {
            (uint256 rateE8, uint256 bondPriceE8, , ) = _calcRateBondToEth(
                bondID,
                poolID
            );
            require(
                rateE8 > MIN_EXCHANGE_RATE_E8,
                "exchange rate is too small"
            );
            require(
                rateE8 < MAX_EXCHANGE_RATE_E8,
                "exchange rate is too large"
            );
            swapPairAmount = _applyDecimalGap(
                bondAmount.mul(rateE8),
                DECIMALS_OF_BOND + 8,
                DECIMALS_OF_ETH
            );
            require(swapPairAmount != 0, "must transfer non-zero token amount");
            volumeE8 = bondPriceE8.mul(bondAmount).div(
                10**uint256(DECIMALS_OF_BOND)
            );
        }

        require(
            bondToken.transferFrom(buyer, seller, bondAmount),
            "fail to transfer bonds"
        );
        _transferEthFrom(seller, buyer, swapPairAmount);

        emit LogExchangeBondToEth(
            buyer,
            bondID,
            poolID,
            bondAmount,
            swapPairAmount,
            volumeE8
        );
    }

    function _calcRateBondToEth(bytes32 bondID, bytes32 poolID)
        internal
        returns (
            uint256 rateE8,
            uint256 bondPriceE8,
            uint256 swapPairPriceE8,
            int256 spreadE8
        )
    {
        (
            ,
            LatestPriceOracleInterface ethOracle,
            BondPricerInterface bondPricer,
            int16 feeBaseE4,
            bool isBondSale
        ) = _getVsEthPool(poolID);
        swapPairPriceE8 = _getLatestPrice(ethOracle);
        (bondPriceE8, spreadE8) = _calcBondPriceAndSpread(
            bondPricer,
            bondID,
            feeBaseE4
        );
        bondPriceE8 = _calcUsdPrice(bondPriceE8);
        rateE8 = bondPriceE8.mul(10**8).div(
            swapPairPriceE8,
            "ERC20 oracle price must be non-zero"
        );

        // `spreadE8` is less than 0.15 * 10**8.
        if (isBondSale) {
            rateE8 = rateE8.mul(uint256(10**8 + spreadE8)) / 10**8;
        } else {
            rateE8 = rateE8.mul(uint256(10**8 - spreadE8)) / 10**8;
        }
    }

    function _generateVsEthPoolID(address seller, bool isBondSale)
        internal
        view
        returns (bytes32 poolID)
    {
        return
            keccak256(
                abi.encode(
                    "Bond vs ETH exchange",
                    address(this),
                    seller,
                    isBondSale
                )
            );
    }

    function _setVsEthPool(
        bytes32 poolID,
        address seller,
        LatestPriceOracleInterface ethOracle,
        BondPricerInterface bondPricer,
        int16 feeBaseE4,
        bool isBondSale
    ) internal {
        require(seller != address(0), "the pool ID already exists");
        require(
            address(ethOracle) != address(0),
            "ethOracle should be non-zero address"
        );
        require(
            address(bondPricer) != address(0),
            "bondPricer should be non-zero address"
        );
        _vsEthPool[poolID] = VsEthPool({
            seller: seller,
            ethOracle: ethOracle,
            bondPricer: bondPricer,
            feeBaseE4: feeBaseE4,
            isBondSale: isBondSale
        });
    }

    function _createVsEthPool(
        address seller,
        LatestPriceOracleInterface ethOracle,
        BondPricerInterface bondPricer,
        int16 feeBaseE4,
        bool isBondSale
    ) internal returns (bytes32 poolID) {
        poolID = _generateVsEthPoolID(seller, isBondSale);
        require(
            _vsEthPool[poolID].seller == address(0),
            "the pool ID already exists"
        );

        {
            uint256 price = ethOracle.latestPrice();
            require(
                price != 0,
                "ethOracle has latestPrice() function which returns non-zero value"
            );
        }

        _setVsEthPool(
            poolID,
            seller,
            ethOracle,
            bondPricer,
            feeBaseE4,
            isBondSale
        );

        if (isBondSale) {
            emit LogCreateEthToBondPool(poolID, seller);
        } else {
            emit LogCreateBondToEthPool(poolID, seller);
        }

        emit LogUpdateVsEthPool(
            poolID,
            address(ethOracle),
            address(bondPricer),
            feeBaseE4
        );
    }

    function _updateVsEthPool(
        bytes32 poolID,
        LatestPriceOracleInterface ethOracle,
        BondPricerInterface bondPricer,
        int16 feeBaseE4
    ) internal isExsistentVsEthPool(poolID) {
        (address seller, , , , bool isBondSale) = _getVsEthPool(poolID);
        _setVsEthPool(
            poolID,
            seller,
            ethOracle,
            bondPricer,
            feeBaseE4,
            isBondSale
        );

        emit LogUpdateVsEthPool(
            poolID,
            address(ethOracle),
            address(bondPricer),
            feeBaseE4
        );
    }

    function _deleteVsEthPool(bytes32 poolID)
        internal
        isExsistentVsEthPool(poolID)
    {
        delete _vsEthPool[poolID];

        emit LogDeleteVsEthPool(poolID);
    }

    function _getVsEthPool(bytes32 poolID)
        internal
        view
        isExsistentVsEthPool(poolID)
        returns (
            address seller,
            LatestPriceOracleInterface ethOracle,
            BondPricerInterface bondPricer,
            int16 feeBaseE4,
            bool isBondSale
        )
    {
        VsEthPool memory exchangePair = _vsEthPool[poolID];
        seller = exchangePair.seller;
        ethOracle = exchangePair.ethOracle;
        bondPricer = exchangePair.bondPricer;
        feeBaseE4 = exchangePair.feeBaseE4;
        isBondSale = exchangePair.isBondSale;
    }

    function _transferEthFrom(
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        _subEthAllowance(sender, amount);
        _transferETH(payable(recipient), amount);
    }

    function _addEthAllowance(address sender, uint256 amount) internal {
        _depositedEth[sender] += amount;
        require(_depositedEth[sender] >= amount, "overflow allowance");
    }

    function _subEthAllowance(address owner, uint256 amount) internal {
        require(_depositedEth[owner] >= amount, "insufficient allowance");
        _depositedEth[owner] -= amount;
    }
}
